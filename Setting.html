<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Setting | Power Amigo</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* --- Basic layout to match Dashboard/Reports --- */
    body { font-family: Arial; margin: 0; display: flex; }
    header {
      background: rgba(255, 255, 255, 0.9);
      position: fixed; top: 0; width: 100%; z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .nav-container { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; max-width: 1200px; margin: auto; }
    .nav-container a { color: #2a9d8f; font-weight: bold; margin-left: 20px; text-decoration: none; font-size: 18px; }
    .nav-container a:hover { text-decoration: underline; }
    .nav-right { display: flex; align-items: center; }
    .search-icon { cursor: pointer; font-size: 20px; color: #2a9d8f; margin-left: 15px; }

    .search-overlay {
      display: none; position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
      width: 60%; background: white; padding: 15px; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 2000;
    }
    .search-container { display: flex; align-items: center; gap: 10px; }
    .search-container input { padding: 10px; font-size: 16px; width: 100%; border: 1px solid #ccc; border-radius: 4px; }
    .search-container button { padding: 10px 20px; background: #e76f51; color: white; border: none; border-radius: 4px; cursor: pointer; }

    .sidebar { width: 200px; background: #2a9d8f; color: white; height: 100vh; padding-top: 80px; position: fixed; top: 0; left: 0; }
    .sidebar a { display: block; padding: 12px 20px; color: white; text-decoration: none; font-weight: bold; font-size: 16px; }
    .sidebar a:hover { background: #248f7d; }

    .main-content { margin-left: 200px; padding: 100px 40px; flex: 1; max-width: 1200px; }

    .controls-row { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 24px; }
    .sensor-dropdown { position: relative; }
    .sensor-toggle-btn {
      background-color: #2a9d8f; color: white; border: none;
      padding: 10px 20px; border-radius: 20px; font-size: 16px;
      cursor: pointer; transition: background-color 0.3s;
    }
    .sensor-toggle-btn[disabled] { opacity: 0.6; cursor: not-allowed; }
    .sensor-toggle-btn:hover { background-color: #248f7d; }
    .dropdown-menu {
      position: absolute; top: 110%; left: 0; background-color: white;
      border: 1px solid #ccc; border-radius: 8px; width: 160px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15); z-index: 1000; display: none;
    }
    .dropdown-menu div { padding: 10px; cursor: pointer; }
    .dropdown-menu div:hover { background-color: #f2f2f2; }

    h1, h2, h3 { color: #2a9d8f; }

    .card { background: #f9f9f9; padding: 20px; border-radius: 10px; box-shadow: 0 1px 5px rgba(0,0,0,0.1); }
    .grid-3 { display: grid; grid-template-columns: repeat(3, minmax(200px, 1fr)); gap: 16px; }
    .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(240px, 1fr)); gap: 16px; }
    .row { display: flex; gap: 20px; align-items: center; }
    label { font-size: 15px; color: #333; min-width: 90px; text-align: right;}
    input[type="number"], input[type="date"] {
      padding: 8px 10px; border: 1px solid #2a9d8f; border-radius: 6px; width: 140px; margin-right: 10px; margin-bottom: 10px;
    }
    button.primary { background: #2a9d8f; color: #fff; border: none; border-radius: 8px; padding: 10px 14px; cursor: pointer; }
    button.secondary { background: #e76f51; color: #fff; border: none; border-radius: 8px; padding: 10px 14px; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { border-bottom: 1px solid #e6e6e6; text-align: left; padding: 10px; font-size: 14px; }
    tr.alert-row { background: #fff3f3; }
    .muted { color: #666; font-size: 14px; line-height: 1.5; margin-top: 4px;}
    .hint { color: #999; font-size: 12px; }
    .section { margin-bottom: 28px; }
	/* ---- Highlight severe alerts ---- */
    tr.alert-row.severe { background-color: #ffcccc; font-weight: bold; }

    /* ---- Floating alert banner ---- */
  #alertBanner {
  display: none;
  position: fixed;
  top: 70px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #ff5959;
  color: white;
  padding: 12px 24px;
  border-radius: 8px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  font-size: 16px;
  font-weight: bold;
  z-index: 3000;
}
    .nav-right button.secondary {
  background: #e76f51;
  border: none;
  border-radius: 8px;
  padding: 6px 12px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.3s;
}
.nav-right button.secondary:hover {
  background: #cf5c3e;
}

 
.main-content .section.card {
  max-width: 1100px;           
  margin: 40px auto;           
  padding: 30px 40px;          
  background: #f9f9f9;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}


    
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="nav-container">
      <div><img src="images/logo.png" alt="Power Amigo Logo" height="40"/></div>
      <div class="nav-right">
        <a href="Dashboard.html">Home</a>
        <a href="#">About Us</a>
        <a href="#">Contact Us</a>
        <a href="Dashboard.html">View Data</a>
        <span class="search-icon" onclick="toggleSearch()">üîç</span>
        <button class="secondary" onclick="logout()" style="margin-left: 20px;">Logout</button>
      </div>
    </div>
  </header>

  <!-- Search overlay -->
  <div id="searchOverlay" class="search-overlay">
    <div class="search-container">
      <input type="text" placeholder="Search ..." />
      <button>SEARCH</button>
    </div>
  </div>
  <div id="alertBanner">Alert detected!</div>

  <!-- Sidebar -->
  <div class="sidebar">
    <a href="Dashboard.html">Dashboard</a>
    <a href="Reports.html">Reports</a>
    <a href="Setting.html">Setting</a>
    <a href="Dashboard.html">Home</a>
  </div>

  <!-- Main -->
  <div class="main-content">
    <h1>Setting</h1>

    <!-- Top selectors -->
    <div class="controls-row">
      <div class="sensor-dropdown">
        <button id="btnInstall" class="sensor-toggle-btn" onclick="toggleInstallMenu()">Select Installation ‚ñæ</button>
        <div id="installDropdown" class="dropdown-menu"></div>
      </div>

      <div class="sensor-dropdown">
        <button id="btnSensor" class="sensor-toggle-btn" onclick="toggleSensorMenu()" disabled>Select Sensor ‚ñæ</button>
        <div id="sensorDropdown" class="dropdown-menu"></div>
      </div>

      <div class="row">
        <label for="datePicker"><strong>Select Day:</strong></label>
        <input type="date" id="datePicker" />
        <button class="primary" onclick="setToday()">Today</button>
        <button class="primary" onclick="setYesterday()">Yesterday</button>
      </div>
    </div>

    <!-- Thresholds per Installation -->
    <div class="section card">
      <h2>Current Thresholds (per Installation)</h2>
      <p class="muted">These thresholds apply only to the currently selected Installation.</p>
      <div class="grid-3">
        <div>
          <h3>Current A</h3>
          <div class="row"><label>Min</label><input id="IA_min" type="number" step="0.01" /></div>
          <div class="row"><label>Max</label><input id="IA_max" type="number" step="0.01" /></div>
        </div>
        <div>
          <h3>Current B</h3>
          <div class="row"><label>Min</label><input id="IB_min" type="number" step="0.01" /></div>
          <div class="row"><label>Max</label><input id="IB_max" type="number" step="0.01" /></div>
        </div>
        <div>
          <h3>Current C</h3>
          <div class="row"><label>Min</label><input id="IC_min" type="number" step="0.01" /></div>
          <div class="row"><label>Max</label><input id="IC_max" type="number" step="0.01" /></div>
        </div>
      </div>
      <div class="row" style="margin-top:12px;">
        <button class="primary" onclick="saveThresholds()">Save Thresholds</button>
        <span id="saveMsg" class="hint"></span>
      </div>
    </div>

    <!-- Alert Monitor comes first -->
    <div class="section card">
      <h2>Alert Monitor</h2>
      <div class="grid-2">
        <div>
          <p class="muted">Scan selected day for out-of-range currents based on thresholds above.</p>
          <div class="row">
            <button class="secondary" onclick="scanDay()">Scan Day</button>
            <button id="btnAuto" class="secondary" onclick="toggleAutoScan()">Start Auto Scan (10s)</button>
          </div>
        </div>
        <div>
          <p class="muted">Export alert results for archiving.</p>
          <div class="row">
            <button class="primary" onclick="exportAlertsCSV()">Export Alerts CSV</button>
          </div>
        </div>
      </div>

      <table id="alertsTable">
        <thead>
          <tr>
            <th>Date</th><th>Time Range</th><th>Installation</th><th>Sensor</th><th>Channel(s)</th><th>Detail</th>
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="6" class="muted">No alerts yet. Click "Scan Day".</td></tr>
        </tbody>
      </table>
    </div>

    <!-- User Management follows after Alert -->
    <div class="section card" id="userManagement">
      <h2>User Management</h2>
      <p class="muted">Manage system users, roles, and account status.</p>

      <table id="userTable">
        <thead>
          <tr><th>Username</th><th>Email</th><th>Role</th><th>Status</th><th>Action</th></tr>
        </thead>
        <tbody id="userTableBody">
          <tr><td colspan="5">Loading users...</td></tr>
        </tbody>
      </table>

      <div class="row" style="margin-top:20px;">
        <input id="newUserName" placeholder="Username" />
        <input id="newUserEmail" placeholder="Email" />
        <select id="newUserRole">
          <option value="user">User</option>
          <option value="admin">Admin</option>
        </select>
        <button class="primary" onclick="addUser()">Add User</button>
      </div>
    </div>
  </div> <!-- proper close main-content -->
</body>
</html>

  <script>
  
    function logout() {
  if (confirm("Are you sure you want to log out?")) {
    localStorage.removeItem("userRole");
    localStorage.removeItem("username");
    alert("You have been logged out.");
    window.location.href = "index.html";
  }
}

    // === ACCESS CONTROL: Admin-only page (temporarily disabled for testing) ===
    // Login check completely removed for testing

    /* ----------- Constants & State ----------- */
    const API_BASE = "https://40btd9hsk0.execute-api.us-east-1.amazonaws.com/sensors";
    const LS_KEY = "POWER_AMIGO_THRESHOLDS_V2"; // store per-installation
    let thresholdsByInstall = {};
    let currentInstallation = null;
    let currentSensor = null;
    let autoScanTimer = null;
    let autoScanCountdown = null;
    let foundAlerts = []; // last scan results

    /* ----------- Utilities ----------- */
    function toggleSearch(){
      const o=document.getElementById("searchOverlay");
      o.style.display=(o.style.display==="block")?"none":"block";
    }

    function toggleInstallMenu(){
      console.log("[setting] toggleInstallMenu()");
      const m=document.getElementById('installDropdown');
      m.style.display=(m.style.display==='block')?'none':'block';
    }
    function toggleSensorMenu(){
      console.log("[setting] toggleSensorMenu()");
      const m=document.getElementById('sensorDropdown');
      m.style.display=(m.style.display==='block')?'none':'block';
    }
    document.addEventListener('click', (e)=>{
      const im=document.getElementById('installDropdown');
      const sd=document.getElementById('sensorDropdown');
      const buttons=document.querySelectorAll('.sensor-toggle-btn');
      const insideBtn=[...buttons].some(b=>b.contains(e.target));
      if(im && !im.contains(e.target) && !insideBtn) im.style.display='none';
      if(sd && !sd.contains(e.target) && !insideBtn) sd.style.display='none';
    });

    function getLocalDateString(dateObj=new Date()){ 
      // Get current date in Brisbane timezone
      const brisbaneTime = new Date(dateObj.toLocaleString("en-US", {timeZone: "Australia/Brisbane"}));
      const year = brisbaneTime.getFullYear();
      const month = String(brisbaneTime.getMonth() + 1).padStart(2, '0');
      const day = String(brisbaneTime.getDate()).padStart(2, '0');
      const result = `${year}-${month}-${day}`;
      console.log("[setting] getLocalDateString:", {
        input: dateObj.toISOString(),
        brisbaneTime: brisbaneTime.toISOString(),
        result: result
      });
      return result;
    }
    function setToday(){
      const d=getLocalDateString();
      document.getElementById('datePicker').value=d;
      console.log("[setting] setToday (Brisbane timezone):", d);
      console.log("[setting] Current time in Brisbane:", new Date().toLocaleString("en-AU", {timeZone: "Australia/Brisbane"}));
    }
    function setYesterday(){
      const y=new Date(); y.setDate(y.getDate()-1);
      const d=getLocalDateString(y);
      document.getElementById('datePicker').value=d;
      console.log("[setting] setYesterday:", d);
    }

    function loadThresholdsFromLS(){
      try{
        thresholdsByInstall = JSON.parse(localStorage.getItem(LS_KEY)||"{}");
        console.log("[setting] thresholds loaded:", thresholdsByInstall);
      }catch(e){
        console.warn("[setting] failed to parse thresholds from LS:", e);
        thresholdsByInstall = {};
      }
    }
    function saveThresholdsToLS(){
      localStorage.setItem(LS_KEY, JSON.stringify(thresholdsByInstall));
      console.log("[setting] thresholds saved to LS:", thresholdsByInstall);
    }

    /* ----------- Installation & Sensor ----------- */
    async function loadInstallations(){
      try{
        console.log("[setting] fetching installations:", API_BASE);
        const res = await fetch(API_BASE);
        console.log("[setting] installations status:", res.status);
        const json = await res.json();
        console.log("[setting] installations json:", json);

        if(!json.items || json.items.length === 0){
          console.warn("[setting] empty items; installations cannot be listed yet");
          return;
        }
        
        const installs = [...new Set(json.items.map(r=>r.Installations).filter(Boolean))].sort();
        console.log("[setting] found installations:", installs);

        const dd = document.getElementById('installDropdown');
        dd.innerHTML = "";
        installs.forEach(name=>{
          const div=document.createElement('div');
          div.textContent=name;
          div.onclick=()=>selectInstallation(name);
          dd.appendChild(div);
        });

        // Auto-select Site_A if available
        if(installs.includes('Site_A')){
          console.log("[setting] auto select Site_A");
          selectInstallation('Site_A');
        } else if(installs.length > 0){
          console.log("[setting] Site_A not found, auto select first installation:", installs[0]);
          selectInstallation(installs[0]);
        } else {
          console.log("[setting] installations loaded, waiting for user selection");
        }
      }catch(err){
        console.error("[setting] loadInstallations failed:", err);
      }
    }

    async function selectInstallation(installation){
      console.log("[setting] selectInstallation:", installation);
      currentInstallation = installation;
      document.getElementById('btnInstall').textContent = installation + " ‚ñæ";
      document.getElementById('installDropdown').style.display='none';

      // Keep sensor button disabled - show all sensors' data instead
      const btnSensor = document.getElementById('btnSensor');
      if (btnSensor) {
        btnSensor.disabled = true;
        btnSensor.textContent = "All Sensors (Disabled)";
      }

      // load its sensors
      await loadSensorsForInstallation(installation);

      // load previously saved thresholds for this installation
      applyThresholdsToForm();
    }

    async function loadSensorsForInstallation(installation){
      try{
        console.log("[setting] loadSensorsForInstallation:", installation);
        const res = await fetch(API_BASE);
        console.log("[setting] sensors status:", res.status);
        const json = await res.json();
        console.log("[setting] sensors json:", json);

        if(!json.items || json.items.length===0){
          console.warn("[setting] empty items; cannot build sensors");
          return;
        }
        const sensors = [...new Set(json.items
          .filter(r => r.Installations === installation)
          .map(r => r.Sensor_id))].sort();
        console.log(`[setting] sensors for ${installation}:`, sensors);

        // Don't auto-fill thresholds - let user input manually
        console.log(`[setting] installation ${installation} selected, thresholds form ready for manual input`);

        const dd = document.getElementById('sensorDropdown');
        dd.innerHTML = "";
        sensors.forEach(id=>{
          const div=document.createElement('div');
          div.textContent=id;
          div.onclick=()=>selectSensor(id);
          dd.appendChild(div);
        });

        // Don't auto-select sensor - show all sensors' data instead
        console.log(`[setting] showing min/max values for all sensors in ${installation}`);
      }catch(err){
        console.error("[setting] loadSensorsForInstallation failed:", err);
      }
    }

    function selectSensor(sensor){
      console.log("[setting] selectSensor:", sensor);
      currentSensor = sensor;
      document.getElementById('btnSensor').textContent = sensor + " ‚ñæ";
      document.getElementById('sensorDropdown').style.display='none';
    }

    // Calculate min/max values for all sensors in an installation
    function calculateMinMaxForInstallation(sensorData){
      console.log("[setting] calculateMinMaxForInstallation with", sensorData.length, "data points");
      console.log("[setting] raw sensor data:", sensorData);
      
      if(sensorData.length === 0) {
        console.log("[setting] no data points, returning zeros");
        return {
          IA: { min: 0, max: 0 },
          IB: { min: 0, max: 0 },
          IC: { min: 0, max: 0 }
        };
      }
      
      // Extract values and ensure they are numbers
      const values = {
        IA: sensorData.map(r => parseFloat(r.IA)).filter(v => !isNaN(v)),
        IB: sensorData.map(r => parseFloat(r.IB)).filter(v => !isNaN(v)),
        IC: sensorData.map(r => parseFloat(r.IC)).filter(v => !isNaN(v))
      };
      
      console.log("[setting] extracted values:", values);
      
      const result = {
        IA: { 
          min: values.IA.length > 0 ? Math.min(...values.IA).toFixed(2) : "0.00", 
          max: values.IA.length > 0 ? Math.max(...values.IA).toFixed(2) : "0.00"
        },
        IB: { 
          min: values.IB.length > 0 ? Math.min(...values.IB).toFixed(2) : "0.00", 
          max: values.IB.length > 0 ? Math.max(...values.IB).toFixed(2) : "0.00"
        },
        IC: { 
          min: values.IC.length > 0 ? Math.min(...values.IC).toFixed(2) : "0.00", 
          max: values.IC.length > 0 ? Math.max(...values.IC).toFixed(2) : "0.00"
        }
      };
      
      console.log("[setting] calculated min/max values:", result);
      return result;
    }

    // Display min/max values in the threshold form
    function displayMinMaxValues(minMaxValues){
      console.log("[setting] displayMinMaxValues:", minMaxValues);
      
      // Update the form fields with the calculated min/max values
      document.getElementById('IA_min').value = minMaxValues.IA.min;
      document.getElementById('IA_max').value = minMaxValues.IA.max;
      document.getElementById('IB_min').value = minMaxValues.IB.min;
      document.getElementById('IB_max').value = minMaxValues.IB.max;
      document.getElementById('IC_min').value = minMaxValues.IC.min;
      document.getElementById('IC_max').value = minMaxValues.IC.max;
      
      // Show a message that these are calculated values
      const saveMsg = document.getElementById('saveMsg');
      if(saveMsg) {
        saveMsg.textContent = "Values calculated from all sensors in this installation";
        saveMsg.style.color = "#2a9d8f";
        setTimeout(() => {
          saveMsg.textContent = "";
        }, 3000);
      }
    }

    /* ----------- Threshold form logic (per installation) ----------- */
    function applyThresholdsToForm(){
      // Don't auto-fill any values - keep form blank for manual input
      console.log("[setting] applyThresholdsToForm for", currentInstallation, "- keeping form blank for manual input");
      
      // Clear all form fields
      document.getElementById('IA_min').value = "";
      document.getElementById('IA_max').value = "";
      document.getElementById('IB_min').value = "";
      document.getElementById('IB_max').value = "";
      document.getElementById('IC_min').value = "";
      document.getElementById('IC_max').value = "";
    }

    function readThresholdsFromForm(){
      const iaMin = Number(document.getElementById('IA_min').value);
      const iaMax = Number(document.getElementById('IA_max').value);
      const ibMin = Number(document.getElementById('IB_min').value);
      const ibMax = Number(document.getElementById('IB_max').value);
      const icMin = Number(document.getElementById('IC_min').value);
      const icMax = Number(document.getElementById('IC_max').value);

      const ok = (a,b)=>!(Number.isNaN(a) || Number.isNaN(b) || a>b);
      if(!ok(iaMin, iaMax) || !ok(ibMin, ibMax) || !ok(icMin, icMax)){
        throw new Error("Invalid thresholds: min must be <= max, and all fields required.");
      }

      return {
        IA: { min: iaMin, max: iaMax },
        IB: { min: ibMin, max: ibMax },
        IC: { min: icMin, max: icMax }
      };
    }

    function saveThresholds(){
      try{
        if(!currentInstallation){ alert("Please select Installation first."); return; }
        console.log("[setting] saveThresholds for", currentInstallation);
        const t = readThresholdsFromForm();
        console.log("[setting] saving thresholds:", t);
        thresholdsByInstall[currentInstallation] = t;
        saveThresholdsToLS();
        console.log("[setting] thresholds saved successfully:", thresholdsByInstall);
        document.getElementById('saveMsg').textContent = "Saved successfully!";
        setTimeout(()=>{document.getElementById('saveMsg').textContent="";}, 1500);
      }catch(err){
        console.error("[setting] saveThresholds error:", err);
        alert(err.message || "Failed to save thresholds.");
      }
    }

    /* ----------- Alert scanning ----------- */
    function getSelectedDate(){
      return document.getElementById('datePicker').value || getLocalDateString();
    }

    function withinRange(val, min, max){
      if(Number.isNaN(val)) return false;
      return val >= min && val <= max;
    }

    function computeMedianStep(timestamps){
      if(timestamps.length<2) return 300000; // 5 min default
      const deltas=[];
      for(let i=1;i<timestamps.length;i++){
        deltas.push(timestamps[i]-timestamps[i-1]);
      }
      deltas.sort((a,b)=>a-b);
      const mid=Math.floor(deltas.length/2);
      return deltas.length%2?deltas[mid]:((deltas[mid-1]+deltas[mid])/2);
    }

    function groupAlertIntervals(points){
      // points: [{ts: Date, channels: ['IA', ...], values: {IA:x,...}, sensor: 'SENSOR_001'}]
      if(points.length===0) return [];
      const tsNums = points.map(p=>p.ts.getTime());
      const step = computeMedianStep(tsNums);
      const tolerance = Math.max(2*1000, Math.floor(step*1.5)); // allow some jitter
      console.log("[setting] grouping intervals. median step(ms):", step, "tolerance:", tolerance);

      const res=[];
      let cur = { 
        start: points[0].ts, 
        end: points[0].ts, 
        channels: new Set(points[0].channels), 
        sensors: new Set([points[0].sensor]),
        samples:[points[0]] 
      };

      for(let i=1;i<points.length;i++){
        const p=points[i];
        const gap = p.ts.getTime()-cur.end.getTime();
        const sameChannels = JSON.stringify([...cur.channels].sort())===JSON.stringify([...new Set(p.channels)].sort());
        if(gap<=tolerance && sameChannels){
          cur.end = p.ts;
          cur.sensors.add(p.sensor);
          cur.samples.push(p);
        }else{
          res.push(cur);
          cur = { 
            start: p.ts, 
            end: p.ts, 
            channels: new Set(p.channels), 
            sensors: new Set([p.sensor]),
            samples:[p] 
          };
        }
      }
      res.push(cur);

      // map to final shape
      return res.map(seg=>{
        const chs=[...seg.channels].join(",");
        const sensorList = [...seg.sensors].join(", ");
        // aggregate detail: min/max over segment by channel
        const agg={};
        for(const p of seg.samples){
          for(const k of Object.keys(p.values)){
            if(p.channels.includes(k)){
              if(!agg[k]) agg[k]={min:p.values[k], max:p.values[k]};
              agg[k].min = Math.min(agg[k].min, p.values[k]);
              agg[k].max = Math.max(agg[k].max, p.values[k]);
            }
          }
        }
        return {
          start: seg.start,
          end: seg.end,
          channels: chs,
          sensor: sensorList,
          detail: Object.entries(agg).map(([k,v])=>`${k}: ${v.min.toFixed(2)} ~ ${v.max.toFixed(2)}`).join("; ")
        };
      });
    }

    async function scanDay(){
      try{
        if(!currentInstallation){ alert("Please select Installation first."); return; }
        
        // In Setting page, we scan all sensors for the selected installation
        // No need to select a specific sensor

        const t = thresholdsByInstall[currentInstallation];
        if(!t){ alert("Please set thresholds for current Installation first."); return; }

        const dateStr = getSelectedDate();
        console.log("[setting] scanDay installation:", currentInstallation, "date:", dateStr);
        console.log("[setting] using thresholds:", t);
        console.log("[setting] all saved thresholds:", thresholdsByInstall);

        const res = await fetch(API_BASE);
        console.log("[setting] scan fetch status:", res.status);
        const json = await res.json();
        console.log("[setting] scan json:", json);

        if(!json.items || json.items.length===0){
          alert("No data returned from API.");
          return;
        }

        // Replace timestamps with current time for testing
        const currentTimestamp = Math.floor(Date.now() / 1000);
        const currentDate = new Date();
        console.log("[setting] Replacing timestamps with current time:", currentTimestamp);
        console.log("[setting] Current date in Brisbane:", currentDate.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"}));
        console.log("[setting] Current UTC time:", currentDate.toISOString());
        console.log("[setting] Current year:", currentDate.getFullYear());
        
        json.items.forEach((item, index) => {
          // Replace ALL timestamps with the SAME current time
          item.timestamp = currentTimestamp;
          
          // Debug: Show the converted date
          const testDate = new Date(item.timestamp * 1000);
          const brisbaneTestTime = testDate.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"});
          console.log(`[${index}] Updated timestamp: ${item.timestamp} -> ${brisbaneTestTime} (UTC: ${testDate.toISOString()})`);
        });
        
        // Verify all timestamps are current
        const minTimestamp = Math.min(...json.items.map(i => i.timestamp));
        const maxTimestamp = Math.max(...json.items.map(i => i.timestamp));
        const minDate = new Date(minTimestamp * 1000);
        const maxDate = new Date(maxTimestamp * 1000);
        console.log("[setting] Timestamp range after update:", {
          min: minTimestamp,
          max: maxTimestamp,
          minDate: minDate.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"}),
          maxDate: maxDate.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"})
        });

        // Debug: Show all data timestamps (Brisbane timezone)
        console.log("[setting] All data timestamps (Brisbane timezone) - UPDATED:");
        json.items.forEach((item, index) => {
          const date = new Date(item.timestamp * 1000);
          const brisbaneTime = date.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"});
          console.log(`[${index}] ${item.Installations} - ${item.Sensor_id} - ${brisbaneTime} (${date.toISOString()}) - IA:${item.IA}, IB:${item.IB}, IC:${item.IC}`);
        });

        // filter by installation + date (scan all sensors in the installation)
        // Use Brisbane timezone for date filtering
        const start = new Date(dateStr+"T00:00:00+10:00"); // Brisbane timezone
        const end = new Date(dateStr+"T23:59:59+10:00");   // Brisbane timezone
        
        console.log("[setting] Date filter range (Brisbane timezone):", {
          selectedDate: dateStr,
          start: start.toISOString(),
          end: end.toISOString(),
          startBrisbane: start.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"}),
          endBrisbane: end.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"})
        });
        
        // Debug: Show what we're looking for vs what we have
        console.log("[setting] Looking for data between:", start.toISOString(), "and", end.toISOString());
        console.log("[setting] Data timestamps range from:", Math.min(...json.items.map(i => i.timestamp)), "to", Math.max(...json.items.map(i => i.timestamp)));
        
        const filtered = json.items.filter(r=>{
          const okInstall = r.Installations === currentInstallation;
          const ts = new Date(r.timestamp*1000);
          const inDateRange = ts >= start && ts <= end;
          const brisbaneTime = ts.toLocaleString("en-AU", {timeZone: "Australia/Brisbane"});
          
          console.log(`[setting] Filter check: ${r.Installations} === ${currentInstallation} = ${okInstall}, ${brisbaneTime} in range = ${inDateRange}`);
          
          return okInstall && inDateRange;
        }).map(r=>({
          ts: new Date(r.timestamp*1000),
          IA: r.IA, IB: r.IB, IC: r.IC,
          sensor: r.Sensor_id  // Keep sensor info for display
        })).sort((a,b)=>a.ts-b.ts);
        console.log("[setting] filtered points:", filtered.length);
        console.log("[setting] sample filtered data:", filtered.slice(0, 3)); // Show first 3 data points

        // build alert points
        const alertsPoints=[];
        for(const p of filtered){
          const channels=[];
          const checks = {
            IA: { value: p.IA, min: t.IA.min, max: t.IA.max, inRange: withinRange(p.IA, t.IA.min, t.IA.max) },
            IB: { value: p.IB, min: t.IB.min, max: t.IB.max, inRange: withinRange(p.IB, t.IB.min, t.IB.max) },
            IC: { value: p.IC, min: t.IC.min, max: t.IC.max, inRange: withinRange(p.IC, t.IC.min, t.IC.max) }
          };
          
          if(!checks.IA.inRange) channels.push("IA");
          if(!checks.IB.inRange) channels.push("IB");
          if(!checks.IC.inRange) channels.push("IC");
          
          if(channels.length){
            console.log("[setting] Alert found:", {
              sensor: p.sensor,
              timestamp: p.ts,
              channels: channels,
              checks: checks
            });
            alertsPoints.push({ 
              ts:p.ts, 
              channels, 
              values:{IA:p.IA, IB:p.IB, IC:p.IC},
              sensor: p.sensor  // Include sensor info
            });
          }
        }
        console.log("[setting] raw alert points:", alertsPoints.length);

        // group to intervals
        const intervals = groupAlertIntervals(alertsPoints);
        console.log("[setting] alert intervals:", intervals.length, intervals);

        // render table
        foundAlerts = intervals.map(seg=>({
          date: dateStr,
          range: `${seg.start.toLocaleString("en-AU", {timeZone: "Australia/Brisbane", hour: '2-digit', minute: '2-digit', second: '2-digit'})} ~ ${seg.end.toLocaleString("en-AU", {timeZone: "Australia/Brisbane", hour: '2-digit', minute: '2-digit', second: '2-digit'})}`,
          installation: currentInstallation,
          sensor: seg.sensor || "Multiple Sensors", // Show sensor info or indicate multiple
          channels: seg.channels,
          detail: seg.detail
        }));
        renderAlertsTable();
      }catch(err){
        console.error("[setting] scanDay failed:", err);
        alert("Scan failed, check console.");
      }
    }

    function renderAlertsTable(){
      const tbody = document.querySelector("#alertsTable tbody");
      tbody.innerHTML = "";
      if(foundAlerts.length===0){
        const tr=document.createElement('tr');
        const td=document.createElement('td');
        td.colSpan=6; td.className="muted"; td.textContent="No alerts for this selection.";
        tr.appendChild(td); tbody.appendChild(tr);
        return;
      }
      for(const a of foundAlerts){
        const tr=document.createElement('tr');
        tr.className="alert-row";
        tr.innerHTML = `
          <td>${a.date}</td>
          <td>${a.range}</td>
          <td>${a.installation}</td>
          <td>${a.sensor}</td>
          <td>${a.channels}</td>
          <td>${a.detail}</td>
        `;
        tbody.appendChild(tr);
      }
	  highlightSevereRows();
    }

    function exportAlertsCSV(){
      if(foundAlerts.length===0){ alert("No alerts to export."); return; }
      console.log("[setting] exportAlertsCSV rows:", foundAlerts.length);
      let csv="Date,Time Range,Installation,Sensor,Channels,Detail\n";
      foundAlerts.forEach(a=>{
        csv+=`${a.date},${a.range},${a.installation},${a.sensor},"${a.channels}","${a.detail}"\n`;
      });
      const blob=new Blob([csv],{type:'text/csv'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url; a.download=`alerts_${currentInstallation}_${currentSensor}_${getSelectedDate()}.csv`; a.click();
      URL.revokeObjectURL(url);
    }

    function toggleAutoScan(){
      const btn=document.getElementById('btnAuto');
      if(autoScanCountdown){
        // Stop countdown
        clearInterval(autoScanCountdown);
        autoScanCountdown=null;
        btn.textContent="Start Auto Scan (10s)";
        btn.disabled=false;
        console.log("[setting] auto-scan countdown stopped");
      }else{
        // Start single scan with countdown
        console.log("[setting] auto-scan countdown started");
        btn.textContent="Stop Countdown";
        btn.disabled=false;
        startSingleScanCountdown();
      }
    }

    function startSingleScanCountdown(){
      const btn=document.getElementById('btnAuto');
      let countdown = 10;
      
      // Update button text with countdown
      btn.textContent=`Next scan in ${countdown}s`;
      
      // Countdown function
      const countdownInterval = setInterval(() => {
        countdown--;
        if(countdown > 0){
          btn.textContent=`Next scan in ${countdown}s`;
        } else {
          // Countdown finished, start scan
          btn.textContent="Scanning...";
          btn.disabled=true;
          clearInterval(countdownInterval);
          autoScanCountdown = null;
          
          // Perform scan
          scanDay().then(() => {
            // After scan completes, reset button
            btn.textContent="Start Auto Scan (10s)";
            btn.disabled=false;
            console.log("[setting] Single scan completed");
          }).catch(err => {
            console.error("[setting] Auto scan error:", err);
            btn.textContent="Start Auto Scan (10s)";
            btn.disabled=false;
          });
        }
      }, 1000);
      
      // Store countdown interval for cleanup
      autoScanCountdown = countdownInterval;
    }

    /* ----------- Bootstrapping ----------- */
    function initDate(){
      const input=document.getElementById('datePicker');
      input.value = getLocalDateString();
    }
    function init(){
      console.log("[setting] init()");
      loadThresholdsFromLS();
      initDate();
      loadInstallations();
      
      // Pre-fill default thresholds for Site A, B, C
      prefillDefaultThresholds();
      
      // Load users for admin management
      loadUsers();
    }
    
    function prefillDefaultThresholds(){
      console.log("[setting] prefillDefaultThresholds()");
      
      // Default thresholds for Site A, B, C
      const defaultThresholds = {
        "Site_A": {
          IA: { min: 0.5, max: 2.0 },
          IB: { min: 0.5, max: 2.0 },
          IC: { min: 0.5, max: 2.0 }
        },
        "Site_B": {
          IA: { min: 0.5, max: 2.0 },
          IB: { min: 0.5, max: 2.0 },
          IC: { min: 0.5, max: 2.0 }
        },
        "Site_C": {
          IA: { min: 0.5, max: 2.0 },
          IB: { min: 0.5, max: 2.0 },
          IC: { min: 0.5, max: 2.0 }
        },
        "Site_D": {
          IA: { min: 0.5, max: 2.0 },
          IB: { min: 0.5, max: 2.0 },
          IC: { min: 0.5, max: 2.0 }
        }
      };
      
      // Only set defaults if not already saved
      Object.keys(defaultThresholds).forEach(site => {
        if (!thresholdsByInstall[site]) {
          thresholdsByInstall[site] = defaultThresholds[site];
          console.log("[setting] Set default thresholds for", site, ":", defaultThresholds[site]);
        }
      });
      
      // Save the updated thresholds
      saveThresholdsToLS();
    }
	function showAlertBanner(message) {
  const banner = document.getElementById("alertBanner");
  banner.textContent = "‚ö†Ô∏è " + message;
  banner.style.display = "block";
  setTimeout(() => {
    banner.style.display = "none";
  }, 3000);
}

    function highlightSevereRows() {
  const rows = document.querySelectorAll("#alertsTable tbody tr.alert-row");

  // Get the threshold configuration of the current installation
  const t = thresholdsByInstall[currentInstallation];
  if (!t) {
    console.warn("[setting] No thresholds found for", currentInstallation);
    return;
  }

  rows.forEach(tr => {
    const detailText = tr.querySelector("td:last-child").textContent;
    const sensor = tr.children[3].textContent;
    const channel = tr.children[4].textContent; // e.g., "IA,IB"

    // Match the current value from the detail text
    const match = detailText.match(/(\d+\.\d+) ~ (\d+\.\d+)/);
    if (match) {
      const minVal = parseFloat(match[1]);
      const maxVal = parseFloat(match[2]);

      // Select the corresponding maximum threshold according to the channel
      let thresholdMax = 0;
      if (channel.includes("IA")) thresholdMax = t.IA.max;
      else if (channel.includes("IB")) thresholdMax = t.IB.max;
      else if (channel.includes("IC")) thresholdMax = t.IC.max;

      // Determine whether it exceeds 10% of the max threshold
      const upperLimit = thresholdMax * 1.1;
      if (maxVal > upperLimit) {
        tr.classList.add("severe");
        showAlertBanner(`${sensor} exceeded 110% of threshold (${channel})!`);
        console.log(`[setting] Severe alert: ${channel} ${maxVal.toFixed(2)} > ${upperLimit.toFixed(2)}`);
      }
    }
  });
}


    window.addEventListener('load', () => {
      console.log("[Setting] Page loaded, checking user role...");
      
      // Check if user is logged in and has admin role
      const userRole = localStorage.getItem('userRole');
      console.log("[Auth] Checking user role:", userRole);
      
      if (!userRole || userRole !== 'admin') {
        console.log("[Auth] Access denied - redirecting to login");
        alert('Please log in first.');
        window.location.href = 'Login.html';
        return;
      }
      
      console.log("[Auth] Admin access granted, initializing...");
      init();
    });
    
    // Add immediate debug log
    console.log("[Setting] Script loaded with login checks enabled");
	
	  const USER_API = "https://b7t3adfkvk.execute-api.us-east-1.amazonaws.com/dev/api/users";

// === Load user list ===
async function loadUsers() {
  console.log("[UserMgmt] Fetching user list...");
  try {
    const res = await fetch(USER_API);
    const users = await res.json();
    console.log("[UserMgmt] Loaded users:", users);

    const tbody = document.getElementById("userTableBody");
    tbody.innerHTML = "";
    users.forEach(u => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
         <td>${u.Username || "‚Äî"}</td>
        <td>${u.Email || "‚Äî"}</td>
        <td>${u.Role || "‚Äî"}</td>
        <td>${u.Status || "‚Äî"}</td>
        <td>
		<button class="secondary" onclick="deleteUser('${u.Username}')">Delete</button>
        </td>
      `;
      tbody.appendChild(tr);
    });
  } catch (err) {
    console.error("[UserMgmt] Failed to load users:", err);
  }
}

// === Add new user ===
async function addUser() {
  const name = document.getElementById("newUserName").value.trim();
  const email = document.getElementById("newUserEmail").value.trim();
  const role = document.getElementById("newUserRole").value;

  if (!name || !email) {
    alert("Please fill in all fields.");
    return;
  }

  try {
    const res = await fetch(USER_API, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ Username: name, Email: email, Role: role })
    });
    console.log("[UserMgmt] Added user:", name);
    alert("User added!");
    loadUsers();
  } catch (err) {
    console.error("[UserMgmt] Failed to add user:", err);
  }
}

// === Delete user (updated version using username) ===
async function deleteUser(username) {
  if (!confirm(`Are you sure you want to delete user "${username}"?`)) return;

  try {
    const res = await fetch(`${USER_API}/${encodeURIComponent(username)}`, {
      method: "DELETE"
    });

    if (res.ok) {
      console.log("[UserMgmt] Deleted user:", username);
      alert(`User "${username}" deleted successfully.`);
      loadUsers(); // refresh user list
    } else {
      const msg = await res.text();
      alert(`Failed to delete user: ${msg || res.statusText}`);
    }
  } catch (err) {
    console.error("[UserMgmt] Failed to delete user:", err);
    alert("An error occurred while deleting user.");
  }
}


// Initialize loading of user list (temporarily disabled for testing)
// User management login check completely removed for testing

  </script>
</body>
</html>
</html>







